(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{169:function(t,e,s){"use strict";s.r(e);var r=s(0),a=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"es6-继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-继承","aria-hidden":"true"}},[t._v("#")]),t._v(" ES6 继承")]),s("p",[t._v("es6 采用 class extends进行继承。")]),s("h2",{attrs:{id:"es6继承和es5继承的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6继承和es5继承的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" es6继承和es5继承的区别")]),s("ul",[s("li",[t._v("es5 的继承实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面。")]),s("li",[t._v("es6 的继承实质是先创造父类的实例对象this，然后再用子类的构造函数修改this。")])]),s("h2",{attrs:{id:"super"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#super","aria-hidden":"true"}},[t._v("#")]),t._v(" super")]),s("p",[t._v("使用super的时候，必须显示指定是作为函数还是作为对象使用，否则会报错。")]),s("p",[t._v("super调用父类的方法时，super会绑定子类的this。")]),s("h2",{attrs:{id:"proto-属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proto-属性","aria-hidden":"true"}},[t._v("#")]),t._v(" __proto__属性")]),s("p",[t._v("每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。")]),s("p",[t._v("子类的__proto__属性表示构造函数的继承，总是指向父类。")]),s("p",[t._v("子类prototype的__proto__属性表示方法的继承，总是指向父类的prototype属性。")]),s("h2",{attrs:{id:"继承目标"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#继承目标","aria-hidden":"true"}},[t._v("#")]),t._v(" 继承目标")]),s("p",[t._v("只要是一个有prototype属性的函数，就能被继承。")]),s("p",[s("a",{attrs:{href:"#es6%E7%BB%A7%E6%89%BF%E5%92%8Ces5%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB"}},[t._v("根据es5和es6继承的区别")]),t._v("：")]),s("p",[t._v("es5无法继承内置构造函数，Boolean，Number，String，Array，Date，Function，RegExp，Error，Object。")]),s("p",[t._v("es6可以，但继承Object不行，（特例，因为无法向父类object传参）。")])])}],!1,null,null,null);e.default=a.exports}}]);
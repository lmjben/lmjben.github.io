(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{264:function(t,v,_){"use strict";_.r(v);var e=_(0),p=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"专业术语"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#专业术语"}},[t._v("#")]),t._v(" 专业术语")]),t._v(" "),_("h2",{attrs:{id:"bigpipe-是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bigpipe-是什么"}},[t._v("#")]),t._v(" bigpipe 是什么")]),t._v(" "),_("p",[t._v("答：bigpipe 常用于服务器端渲染，当后端在渲染一个非常耗时的页面时，可以一边渲染，一边输出 html 给前端，此时前端也会根据接收到的 html 片段同步进行渲染。")]),t._v(" "),_("p",[t._v("原理：http1.1 中引入了一个 http 首部，Transfer-Encoding:chunked。这个首部标识了实体采用 chunked 编码传输，chunked 编码可以将实体分割成多个 PageLet 的小块进行传输，并且 chunked 编码的每一块内容都会自标识长度。")]),t._v(" "),_("h2",{attrs:{id:"fp-fcp-fmp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#fp-fcp-fmp"}},[t._v("#")]),t._v(" FP FCP FMP")]),t._v(" "),_("p",[t._v("FP：初次渲染")]),t._v(" "),_("p",[t._v("初次有内容的渲染 FCP")]),t._v(" "),_("p",[t._v("初次有意义的渲染 FMP")]),t._v(" "),_("h2",{attrs:{id:"客户端渲染，预渲染，服务器端渲染，同构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#客户端渲染，预渲染，服务器端渲染，同构"}},[t._v("#")]),t._v(" 客户端渲染，预渲染，服务器端渲染，同构")]),t._v(" "),_("p",[t._v("客户端渲染：直接加载一个空壳，然后通过 js 去加载页面，常见的有 react，vue。")]),t._v(" "),_("ul",[_("li",[t._v("fp 快")]),t._v(" "),_("li",[t._v("fcp 慢")]),t._v(" "),_("li",[t._v("fmp 慢")])]),t._v(" "),_("p",[t._v("预渲染：在客户端渲染的基础上，通过审查元素，抓取到静态 HTML，交给客户端。")]),t._v(" "),_("ul",[_("li",[t._v("fp 中")]),t._v(" "),_("li",[t._v("fcp 快")]),t._v(" "),_("li",[t._v("fmp 中")])]),t._v(" "),_("p",[t._v("服务器端渲染：传统模式的渲染，服务器端将渲染好的 HTML 发给客户端。")]),t._v(" "),_("ul",[_("li",[t._v("fp 慢")]),t._v(" "),_("li",[t._v("fcp 慢")]),t._v(" "),_("li",[t._v("fmp 快")])]),t._v(" "),_("p",[t._v("服务器端同构：浏览器刷新时请求服务器端渲染，在页面跳转时，由客户端渲染接管。")])])}),[],!1,null,null,null);v.default=p.exports}}]);
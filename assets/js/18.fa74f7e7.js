(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{242:function(t,v,e){"use strict";e.r(v);var _=e(0),a=Object(_.a)({},function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"专业术语"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#专业术语","aria-hidden":"true"}},[t._v("#")]),t._v(" 专业术语")]),t._v(" "),e("h2",{attrs:{id:"bigpipe-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bigpipe-是什么","aria-hidden":"true"}},[t._v("#")]),t._v(" bigpipe 是什么")]),t._v(" "),e("p",[t._v("答：bigpipe 常用于服务器端渲染，当后端在渲染一个非常耗时的页面时，可以一边渲染，一边输出 html 给前端，此时前端也会根据接收到的 html 片段同步进行渲染。")]),t._v(" "),e("p",[t._v("原理：http1.1 中引入了一个 http 首部，Transfer-Encoding:chunked。这个首部标识了实体采用 chunked 编码传输，chunked 编码可以将实体分割成多个 PageLet 的小块进行传输，并且 chunked 编码的每一块内容都会自标识长度。")]),t._v(" "),e("h2",{attrs:{id:"fp-fcp-fmp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fp-fcp-fmp","aria-hidden":"true"}},[t._v("#")]),t._v(" FP FCP FMP")]),t._v(" "),e("p",[t._v("FP：初次渲染")]),t._v(" "),e("p",[t._v("初次有内容的渲染 FCP")]),t._v(" "),e("p",[t._v("初次有意义的渲染 FMP")]),t._v(" "),e("h2",{attrs:{id:"客户端渲染，预渲染，服务器端渲染，同构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#客户端渲染，预渲染，服务器端渲染，同构","aria-hidden":"true"}},[t._v("#")]),t._v(" 客户端渲染，预渲染，服务器端渲染，同构")]),t._v(" "),e("p",[t._v("客户端渲染：直接加载一个空壳，然后通过 js 去加载页面，常见的有 react，vue。")]),t._v(" "),e("ul",[e("li",[t._v("fp 快")]),t._v(" "),e("li",[t._v("fcp 慢")]),t._v(" "),e("li",[t._v("fmp 慢")])]),t._v(" "),e("p",[t._v("预渲染：在客户端渲染的基础上，通过审查元素，抓取到静态 HTML，交给客户端。")]),t._v(" "),e("ul",[e("li",[t._v("fp 中")]),t._v(" "),e("li",[t._v("fcp 快")]),t._v(" "),e("li",[t._v("fmp 中")])]),t._v(" "),e("p",[t._v("服务器端渲染：传统模式的渲染，服务器端将渲染好的 HTML 发给客户端。")]),t._v(" "),e("ul",[e("li",[t._v("fp 慢")]),t._v(" "),e("li",[t._v("fcp 慢")]),t._v(" "),e("li",[t._v("fmp 快")])]),t._v(" "),e("p",[t._v("服务器端同构：浏览器刷新时请求服务器端渲染，在页面跳转时，由客户端渲染接管。")])])},[],!1,null,null,null);v.default=a.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{169:function(e,a,v){"use strict";v.r(a);var t=v(0),_=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,v=e._self._c||a;return v("div",{staticClass:"content"},[v("h1",{attrs:{id:"nodejs-使用总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-使用总结","aria-hidden":"true"}},[e._v("#")]),e._v(" NodeJs 使用总结")]),e._v(" "),v("p",[e._v("Node 的特点主要有异步 IO，单线程。")]),e._v(" "),v("h2",{attrs:{id:"异步-io-的好处"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异步-io-的好处","aria-hidden":"true"}},[e._v("#")]),e._v(" 异步 IO 的好处")]),e._v(" "),v("ul",[v("li",[e._v("前端通过异步 IO 可以消除阻塞。")]),e._v(" "),v("li",[e._v("请求耗时少，假如有两个请求 A 和 B，那么异步 IO 用时为：Max（A+B）。同步则为 A+B，请求越多差距越大。")]),e._v(" "),v("li",[e._v("IO 是昂贵的，分布式 IO 是更昂贵的。")]),e._v(" "),v("li",[e._v("Nodejs 适用于 IO 密集型，而不适用于 CPU 密集型。")]),e._v(" "),v("li",[e._v("并不是所有都用异步任务好，遵循一个公式： s= (Ws+Wp)/(Ws+Wp/p) Ws 表示同步任务，Wp 表示异步任务，p 表示处理器的数量。")])]),e._v(" "),v("h2",{attrs:{id:"node-对异步-io-的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node-对异步-io-的实现","aria-hidden":"true"}},[e._v("#")]),e._v(" Node 对异步 IO 的实现")]),e._v(" "),v("p",[v("img",{attrs:{src:"/blog/node-async.png",alt:"异步IO"}})]),e._v(" "),v("div",{staticClass:"tip custom-block"},[v("p",{staticClass:"custom-block-title"},[e._v("提示")]),e._v(" "),v("p",[e._v("libuv 在 linux 下是 custom threadpool。")]),e._v(" "),v("p",[e._v("libuv 在 windows 下是 iocp。")])]),e._v(" "),v("h2",{attrs:{id:"常用的实现异步-io-的方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用的实现异步-io-的方式","aria-hidden":"true"}},[e._v("#")]),e._v(" 常用的实现异步 IO 的方式")]),e._v(" "),v("ul",[v("li",[e._v("step，wind，bigpipe 等异步控制库。")]),e._v(" "),v("li",[e._v("Async、Await。")]),e._v(" "),v("li",[e._v("Promise/Defferred")]),e._v(" "),v("li",[e._v("协程，Node 暂不支持，可使用 Generator。")])]),e._v(" "),v("h2",{attrs:{id:"node-内存管理与优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node-内存管理与优化","aria-hidden":"true"}},[e._v("#")]),e._v(" Node 内存管理与优化")]),e._v(" "),v("p",[e._v("Node 采用 V8 的 分代式垃圾回收策略，分为新生代和老生代内存。")]),e._v(" "),v("ul",[v("li",[e._v("新生代内存主要通过 Scavenge 算法，分为 From 和 To。")]),e._v(" "),v("li",[e._v("老生代内存主要通过 Mark-Sweep 和 Mark-compact，标记清除和移动清除。")])]),e._v(" "),v("h2",{attrs:{id:"常见的内存泄漏"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的内存泄漏","aria-hidden":"true"}},[e._v("#")]),e._v(" 常见的内存泄漏")]),e._v(" "),v("ul",[v("li",[e._v("无线增长的数组。")]),e._v(" "),v("li",[e._v("无限制设置对象额属性和值。")]),e._v(" "),v("li",[e._v("任何模块的私有变量都是永驻的。")]),e._v(" "),v("li",[e._v("大循环，无 GC 机会。")]),e._v(" "),v("li",[e._v("队列消费不及时。")]),e._v(" "),v("li",[e._v("慎用全局变量。")])]),e._v(" "),v("h2",{attrs:{id:"node-调试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node-调试","aria-hidden":"true"}},[e._v("#")]),e._v(" Node 调试")]),e._v(" "),v("ul",[v("li",[e._v("node --inspect app.js")]),e._v(" "),v("li",[e._v("chrome://inspect/#devices")]),e._v(" "),v("li",[e._v("没经过压力测试的 Node 代码基本只完成 10%。")]),e._v(" "),v("li",[e._v("准确计算 QPS 未雨绸缪。")]),e._v(" "),v("li",[e._v("合理利用压力测试工具。")])]),e._v(" "),v("h2",{attrs:{id:"node-项目上线"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node-项目上线","aria-hidden":"true"}},[e._v("#")]),e._v(" Node 项目上线")]),e._v(" "),v("ul",[v("li",[e._v("前端工程化，静态资源上传到 CDN。")]),e._v(" "),v("li",[e._v("单测、压测，性能分析工具找 Bug。")]),e._v(" "),v("li",[e._v("编写 nginx-conf 实现负载均衡和反向代理。")]),e._v(" "),v("li",[e._v("开启 pm2 守护进程，小流量灰度上线。")])]),e._v(" "),v("h2",{attrs:{id:"node-项目运行流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node-项目运行流程","aria-hidden":"true"}},[e._v("#")]),e._v(" Node 项目运行流程")]),e._v(" "),v("p",[e._v("1、用户请求 Node 服务器")]),e._v(" "),v("p",[e._v("2、经过 Nginx 服务器，反向代理，负载均衡到多个 pm2 运行的机器上。")]),e._v(" "),v("p",[e._v("3、pm2 守护进程，保证 Node 进程永远都活着,0 秒的重载。")]),e._v(" "),v("p",[e._v("4、varnish、squid，实现 http 缓存。")]),e._v(" "),v("p",[e._v("5、Java 后台服务器，读写分离，操作数据库，读写数据。")]),e._v(" "),v("p",[e._v("6、Database。")])])}],!1,null,null,null);_.options.__file="project-node.md";a.default=_.exports}}]);
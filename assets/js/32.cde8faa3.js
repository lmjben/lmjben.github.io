(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{232:function(t,e,s){"use strict";s.r(e);var a=s(0),r=Object(a.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),s("p",[t._v("React Fiber 是 Facebook 折腾两年多做出来的东西，是对核心算法的一次重新实现。虽然对开发层面是无感的，但是对于 React 整个架构的优化是非常到位了，目前还没看出有其他框架能超越的地方，当前阶段出的很多新特性（Concurrent Rendering）等都是在 Fiber 基础上实现的。")]),t._v(" "),s("p",[t._v("React Fiber 把更新过程碎片化，每执行完一段更新过程，就把控制权交还给 React 负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。")]),t._v(" "),s("p",[t._v("React Fiber 分为 2 个阶段：render phase 和 commit phase。")]),t._v(" "),t._m(2),t._v(" "),s("p",[t._v("render 和 render 以前的生命周期，都属于 render phase。在这个阶段执行过程中会根据任务的优先级，选择执行或者暂停。故可能发生某个生命周期被执行多次的情况。")]),t._v(" "),s("p",[t._v("getDerivedStateFromError 专门用来捕获 render phase 阶段错误，服务器端渲染时会被调用到。")]),t._v(" "),t._m(3),t._v(" "),s("p",[t._v("render 之后的生命周期，都属于 commit phase。在这个阶段执行过程中不会被打断，会一直执行到底。")]),t._v(" "),s("p",[t._v("componentDidCatch 专门用来捕获 commit phase 阶段错误，服务器端渲染不会被调用到。")]),t._v(" "),t._m(4),t._v(" "),s("p",[t._v("Suspense 要解决的两个问题：1. 代码分片； 2. 异步获取数据。")]),t._v(" "),s("p",[t._v("如果有一个页面的代码引入了 1 个非常大的包，打包的时候会让最终的体积变得非常大，这个时候就需要进行懒加载。")]),t._v(" "),t._m(5),s("p",[t._v("Suspense 的原理：")]),t._v(" "),s("p",[t._v("suspense 组件内部实现了 getDerivedStateFromError 方法，可以用来捕获子元素的报错信息，如果是一个异步组件，会抛出一个 proimise，来让 suspense 捕获到，然后等到异步组件加载完成，尝试重新渲染这个异步组件。")]),t._v(" "),t._m(6),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),s("p",[t._v("React 组件的构造函数将会在装配之前被调用。构造函数是初始化状态的合适位置。")]),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),s("p",[t._v("将虚拟 DOM 渲染成真实的 DOM。")]),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),s("p",[t._v("同上。")]),t._v(" "),t._m(18),t._v(" "),s("p",[t._v("此方法仅作为性能优化存在。不要依赖它来“防止”渲染，因为这可能导致错误。考虑使用内置 PureComponent 而不是 shouldComponentUpdate()手写。")]),t._v(" "),t._m(19),t._v(" "),s("p",[t._v("将虚拟 DOM 渲染成真实的 DOM。")]),t._v(" "),t._m(20),t._v(" "),s("p",[t._v("在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。")]),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),s("p",[t._v("不建议在这个生命中期中获取异步数据：")]),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),s("p",[t._v("UNSAFE_componentWillReceiveProps(nextProps)")]),t._v(" "),s("p",[t._v("使用不当可能体现为组件陷入渲染死循环，他会一直接受新的外部状态导致自身一直在重渲染。导致被多次调用，循环调用。")]),t._v(" "),s("p",[t._v("例如：在 componentWillReceiveProps 中 setState 引起父组件渲染。")]),t._v(" "),t._m(32),t._v(" "),s("p",[t._v("本意：在 render 方法之前. 使用该方法做一些更新之前的准备工作, 例如读取当前某个 DOM。")]),t._v(" "),s("p",[t._v("不合理处：该生命周期有可能在一次更新中被调用多次, 也就是说写在这里的回调函数也有可能会被调用多次, 这显然是不可取的。")]),t._v(" "),s("p",[t._v("更新前读取当前某个 DOM 元素的状态，用 getSnapshotBeforeUpdate 代替。")]),t._v(" "),s("p",[t._v("不能 setState，也会导致循环渲染问题。")]),t._v(" "),s("p",[s("a",{attrs:{href:"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/",target:"_blank",rel:"noopener noreferrer"}},[t._v("生命周期图"),s("OutboundLink")],1)]),t._v(" "),t._m(33),t._v(" "),t._m(34),t._v(" "),s("p",[t._v("React 其实自己实现了一套事件机制，首先我们考虑一下以下代码：")]),t._v(" "),t._m(35),s("p",[t._v("以上类似代码想必大家经常会写到，但是你是否考虑过点击事件是否绑定在了每一个标签上？事实当然不是，JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 document 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。")]),t._v(" "),s("p",[t._v("另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。")]),t._v(" "),s("p",[t._v("那么实现合成事件的目的是什么呢？总的来说在我看来好处有两点，分别是：")]),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),s("p",[t._v("我们通过使 React 变成一种单一数据源的状态来结合二者。React 负责渲染表单的组件，仍然控制用户后续输入时所发生的变化。相应的，其值由 React 控制的输入表单元素称为“受控组件”。")]),t._v(" "),s("p",[t._v("使用”受控组件”，每个状态的改变都有一个与之相关的处理函数。这样就可以直接修改或验证用户输入。")]),t._v(" "),t._m(39),t._v(" "),s("p",[t._v("将 setState() 认为是一次请求而不是一次立即执行更新组件的命令。为了更为可观的性能，React 可能会推迟它，稍后会一次性更新这些组件。React 不会保证在 setState 之后，能够立刻拿到改变的结果。")]),t._v(" "),t._m(40),t._v(" "),t._m(41),t._v(" "),s("p",[t._v("1、当处于生命周期 render 之后的生命周期中。")]),t._v(" "),s("p",[t._v("2、合成事件中（jsx 中的事件都是合成事件）。")]),t._v(" "),t._m(42),t._v(" "),t._m(43),t._v(" "),s("p",[t._v("1、使用 shouldComponentUpdate 和 Immutable 组合控制合适的时间渲染。PureComponent。")]),t._v(" "),s("p",[t._v("2、render 里面尽量减少新建变量和 bind 函数，传递参数是尽量减少传递参数的数量。")]),t._v(" "),s("p",[t._v("3、多个 react 组件性能优化，key 的优化。")]),t._v(" "),s("p",[t._v("4、redux 性能优化：reselect（数据获取时优化）。")]),t._v(" "),t._m(44),t._v(" "),s("p",[t._v("1、如果在 Component 中需要在某个时间点改变，那么应该使用 state，否则应该使用 prop。")]),t._v(" "),s("p",[t._v("2、state 是组件在内部管理自己的状态。")]),t._v(" "),s("p",[t._v("3、prop 只能是父组件传入，或者是初始化时自定义，一旦定义，不能改变。")]),t._v(" "),s("p",[t._v("无状态组件： 只有 prop，没有 state。除了这个 render 功能之外没有多少事情发生，所有的逻辑都围绕着 prop。")]),t._v(" "),t._m(45)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"react-核心知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-核心知识","aria-hidden":"true"}},[this._v("#")]),this._v(" React 核心知识")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"react-fiber"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber","aria-hidden":"true"}},[this._v("#")]),this._v(" React Fiber")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"render-phase-阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#render-phase-阶段","aria-hidden":"true"}},[this._v("#")]),this._v(" render phase 阶段")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"commit-phase-阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#commit-phase-阶段","aria-hidden":"true"}},[this._v("#")]),this._v(" commit phase 阶段")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"suspense"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#suspense","aria-hidden":"true"}},[this._v("#")]),this._v(" Suspense")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"language-jsx line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-jsx"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Usage of Clock")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Clock "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" React"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("lazy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"start importing Clock"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"./Clock"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Suspense")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n  ")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" show "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Clock")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n")]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Suspense")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getDerivedStateFromError")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("error")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isPromise")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("reRender"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"react-生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-生命周期","aria-hidden":"true"}},[this._v("#")]),this._v(" React 生命周期")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"创建时"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建时","aria-hidden":"true"}},[this._v("#")]),this._v(" 创建时")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"constructor"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#constructor","aria-hidden":"true"}},[this._v("#")]),this._v(" constructor")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"static-getderivedstatefromprops"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#static-getderivedstatefromprops","aria-hidden":"true"}},[this._v("#")]),this._v(" static getDerivedStateFromProps")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("组件实例化后和接受新属性时将会调用 getDerivedStateFromProps。它应该返回一个对象来更新状态，或者返回 null 来表明新属性不需要更新任何状态。getDerivedStateFromProps 只存在一个目的。它"),e("strong",[this._v("使组件能够根据 props 的更改来更新其内部状态")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("getDerivedStateFromProps 之所以是"),e("strong",[this._v("静态")]),this._v("的，是因为 static 方法中不能获取到实例对象上的 state 和方法，所以这个方法内不能调用 setState，这就可以避免不守规矩的程序员误用。可以看出 react 对新的生命周期考虑还是挺周全的。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"render"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#render","aria-hidden":"true"}},[this._v("#")]),this._v(" render")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"componentdidmount"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#componentdidmount","aria-hidden":"true"}},[this._v("#")]),this._v(" componentDidMount")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("组件初次渲染后被触发。可以获取到真实的 DOM 元素。若你需要从远端加载数据，"),e("strong",[this._v("这是一个适合实现网络请求的地方")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"更新时"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更新时","aria-hidden":"true"}},[this._v("#")]),this._v(" 更新时")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"getderivedstatefromprops"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#getderivedstatefromprops","aria-hidden":"true"}},[this._v("#")]),this._v(" getDerivedStateFromProps")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"shouldcomponentupdate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate","aria-hidden":"true"}},[this._v("#")]),this._v(" shouldComponentUpdate")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"render-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#render-2","aria-hidden":"true"}},[this._v("#")]),this._v(" render")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"getsnapshotbeforeupdate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#getsnapshotbeforeupdate","aria-hidden":"true"}},[this._v("#")]),this._v(" getSnapshotBeforeUpdate")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("触发时间: update 发生的时候，在 render 之后，在组件 dom 渲染之前。")]),this._v(" "),e("li",[this._v("返回一个值，作为 componentDidUpdate 的第三个参数。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"componentdidupdate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#componentdidupdate","aria-hidden":"true"}},[this._v("#")]),this._v(" componentDidUpdate")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("componentDidUpdate(prevProps, prevState, snapshot) "),e("strong",[this._v("这也是进行网络请求的好地方")]),this._v("。如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"卸载时"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#卸载时","aria-hidden":"true"}},[this._v("#")]),this._v(" 卸载时")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"componentwillunmount"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#componentwillunmount","aria-hidden":"true"}},[this._v("#")]),this._v(" componentWillUnmount")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("componentWillUnmount")]),this._v("在卸载和销毁组件之前立即调用。在此方法中执行任何必要的清理，例如使计时器无效，取消网络请求或清除在其中创建的任何订阅。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"弃用生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#弃用生命周期","aria-hidden":"true"}},[this._v("#")]),this._v(" 弃用生命周期")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"componentwillmount"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#componentwillmount","aria-hidden":"true"}},[this._v("#")]),this._v(" componentWillMount")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("componentWillMount")]),this._v(" 是在 "),e("code",[this._v("render")]),this._v(" 之前执行。通常用来情况下，推荐用 constructor()方法代替。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("react filber 中可能多次调用 render 之前的生命周期函数，可能会请求多次。")]),this._v(" "),e("li",[this._v("在服务器端渲染时，服务器端会执行一次，客户端也会执行一次。")]),this._v(" "),e("li",[this._v("如果请求在 componentWillMount，react 并没有挂载到 dom 上，这时候 setState 可能会有问题。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"componentwillreceiveprops"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#componentwillreceiveprops","aria-hidden":"true"}},[this._v("#")]),this._v(" componentWillReceiveProps")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"componentwillupdate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#componentwillupdate","aria-hidden":"true"}},[this._v("#")]),this._v(" componentWillUpdate")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"常见问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见问题","aria-hidden":"true"}},[this._v("#")]),this._v(" 常见问题")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"简述一下-react-中的事件机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简述一下-react-中的事件机制","aria-hidden":"true"}},[this._v("#")]),this._v(" 简述一下 React 中的事件机制")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("Test")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" handleClick "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("item"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" index")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("span onClick"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("handleClick"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("span"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力。")]),this._v(" "),e("li",[this._v("对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"什么是可控组件和不可控组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是可控组件和不可控组件","aria-hidden":"true"}},[this._v("#")]),this._v(" 什么是可控组件和不可控组件")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在 HTML 当中，像"),e("code",[this._v("<input>")]),this._v(","),e("code",[this._v("<textarea>")]),this._v(", 和 "),e("code",[this._v("<select>")]),this._v("这类表单元素会维持自身的值 value，并根据用户输入进行更新。但在 React 中，可变的状态是保存在组件的状态属性中，并且只能用 setState() 方法进行更新。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"react-异步渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-异步渲染","aria-hidden":"true"}},[this._v("#")]),this._v(" React 异步渲染")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ul",[s("li",[t._v("在 setState 中调用了 enqueueSetState 方法将传入的 state 放到一个队列中。")]),t._v(" "),s("li",[t._v("enqueueSetState 中先是找到需渲染组件并将新的 state 并入该组件的需更新的 state 队列中，接下来调用了 enqueueUpdate 方法。")]),t._v(" "),s("li",[t._v("isBatchingUpdates 标识是否在一个更新组件的事务流中。\n"),s("ul",[s("li",[t._v("如果没有在事务流中，调用 batchedUpdates 方法进入更新流程，进入流程后，会将 isBatchingUpdates 设置为 true。")]),t._v(" "),s("li",[t._v("否则，将需更新的组件放入 dirtyComponents 中。")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"什么时候会标识-isbatchingupdates-为-true"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么时候会标识-isbatchingupdates-为-true","aria-hidden":"true"}},[this._v("#")]),this._v(" 什么时候会标识 isBatchingUpdates 为 true")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"tip custom-block"},[e("p",{staticClass:"custom-block-title"},[this._v("提示")]),this._v(" "),e("p",[this._v("所以在 setTimeout，源生事件中的 setState 会同步渲染。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"react-怎样提高性能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-怎样提高性能","aria-hidden":"true"}},[this._v("#")]),this._v(" react 怎样提高性能")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"props-和-state-分别在什么时候用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#props-和-state-分别在什么时候用","aria-hidden":"true"}},[this._v("#")]),this._v(" props 和 state 分别在什么时候用")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("纯静态展示,可读性更好，并能大大减少代码量。")]),this._v(" "),e("li",[this._v("省去了多余的生命周期，提升了整体的渲染性能。")]),this._v(" "),e("li",[this._v("可复用性强。")])])}],!1,null,null,null);e.default=r.exports}}]);
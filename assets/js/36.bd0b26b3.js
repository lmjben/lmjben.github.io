(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{168:function(a,e,v){"use strict";v.r(e);var t=v(0),_=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,e=a.$createElement,v=a._self._c||e;return v("div",{staticClass:"content"},[v("h1",{attrs:{id:"node-浅析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node-浅析","aria-hidden":"true"}},[a._v("#")]),a._v(" Node 浅析")]),a._v(" "),v("p",[a._v("Node 的特点主要有异步 IO，单线程。")]),a._v(" "),v("h2",{attrs:{id:"异步-io-的好处"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异步-io-的好处","aria-hidden":"true"}},[a._v("#")]),a._v(" 异步 IO 的好处")]),a._v(" "),v("ul",[v("li",[a._v("前端通过异步 IO 可以消除阻塞。")]),a._v(" "),v("li",[a._v("请求耗时少，假如有两个请求 A 和 B，那么异步 IO 用时为：Max（A+B）。同步则为 A+B，请求越多差距越大。")]),a._v(" "),v("li",[a._v("IO 是昂贵的，分布式 IO 是更昂贵的。")]),a._v(" "),v("li",[a._v("Nodejs 适用于 IO 密集型，而不适用于 CPU 密集型。")]),a._v(" "),v("li",[a._v("并不是所有都用异步任务好，遵循一个公式： s= (Ws+Wp)/(Ws+Wp/p) Ws 表示同步任务，Wp 表示异步任务，p 表示处理器的数量。")])]),a._v(" "),v("h2",{attrs:{id:"node-对异步-io-的实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node-对异步-io-的实现","aria-hidden":"true"}},[a._v("#")]),a._v(" Node 对异步 IO 的实现")]),a._v(" "),v("p",[v("img",{attrs:{src:"/blog/node-async.png",alt:"异步IO"}})]),a._v(" "),v("div",{staticClass:"tip custom-block"},[v("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),v("p",[a._v("libuv 在 linux 下是 custom threadpool。")]),a._v(" "),v("p",[a._v("libuv 在 windows 下是 iocp。")])]),a._v(" "),v("h2",{attrs:{id:"常用的实现异步-io-的方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用的实现异步-io-的方式","aria-hidden":"true"}},[a._v("#")]),a._v(" 常用的实现异步 IO 的方式")]),a._v(" "),v("ul",[v("li",[a._v("step，wind，bigpipe 等异步控制库。")]),a._v(" "),v("li",[a._v("Async、Await。")]),a._v(" "),v("li",[a._v("Promise/Defferred")]),a._v(" "),v("li",[a._v("协程，Node 暂不支持，可使用 Generator。")])]),a._v(" "),v("h2",{attrs:{id:"node-内存管理与优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node-内存管理与优化","aria-hidden":"true"}},[a._v("#")]),a._v(" Node 内存管理与优化")]),a._v(" "),v("p",[a._v("Node 采用 V8 的 分代式垃圾回收策略，分为新生代和老生代内存。")]),a._v(" "),v("ul",[v("li",[a._v("新生代内存主要通过 Scavenge 算法，分为 From 和 To。")]),a._v(" "),v("li",[a._v("老生代内存主要通过 Mark-Sweep 和 Mark-compact，标记清除和移动清除。")])]),a._v(" "),v("h2",{attrs:{id:"常见的内存泄漏"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的内存泄漏","aria-hidden":"true"}},[a._v("#")]),a._v(" 常见的内存泄漏")]),a._v(" "),v("ul",[v("li",[a._v("无线增长的数组。")]),a._v(" "),v("li",[a._v("无限制设置对象额属性和值。")]),a._v(" "),v("li",[a._v("任何模块的私有变量都是永驻的。")]),a._v(" "),v("li",[a._v("大循环，无 GC 机会。")]),a._v(" "),v("li",[a._v("队列消费不及时。")]),a._v(" "),v("li",[a._v("慎用全局变量。")])]),a._v(" "),v("h2",{attrs:{id:"node-调试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node-调试","aria-hidden":"true"}},[a._v("#")]),a._v(" Node 调试")]),a._v(" "),v("ul",[v("li",[a._v("node --inspect app.js")]),a._v(" "),v("li",[a._v("chrome://inspect/#devices")]),a._v(" "),v("li",[a._v("没经过压力测试的 Node 代码基本只完成 10%。")]),a._v(" "),v("li",[a._v("准确计算 QPS 未雨绸缪。")]),a._v(" "),v("li",[a._v("合理利用压力测试工具。")])]),a._v(" "),v("h2",{attrs:{id:"node-项目上线"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node-项目上线","aria-hidden":"true"}},[a._v("#")]),a._v(" Node 项目上线")]),a._v(" "),v("ul",[v("li",[a._v("前端工程化，静态资源上传到 CDN。")]),a._v(" "),v("li",[a._v("单测、压测，性能分析工具找 Bug。")]),a._v(" "),v("li",[a._v("编写 nginx-conf 实现负载均衡和反向代理。")]),a._v(" "),v("li",[a._v("开启 pm2 守护进程，小流量灰度上线。")])]),a._v(" "),v("h2",{attrs:{id:"node-项目运行流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#node-项目运行流程","aria-hidden":"true"}},[a._v("#")]),a._v(" Node 项目运行流程")]),a._v(" "),v("p",[a._v("1、用户请求 Node 服务器")]),a._v(" "),v("p",[a._v("2、经过 Nginx 服务器，反向代理，负载均衡到多个 pm2 运行的机器上。")]),a._v(" "),v("p",[a._v("3、pm2 守护进程，保证 Node 进程永远都活着,0 秒的重载。")]),a._v(" "),v("p",[a._v("4、varnish、squid，实现 http 缓存。")]),a._v(" "),v("p",[a._v("5、Java 后台服务器，读写分离，操作数据库，读写数据。")]),a._v(" "),v("p",[a._v("6、Database。")])])}],!1,null,null,null);_.options.__file="node.md";e.default=_.exports}}]);
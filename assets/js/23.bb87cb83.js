(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{295:function(s,t,v){"use strict";v.r(t);var _=v(0),a=Object(_.a)({},(function(){var s=this,t=s.$createElement,v=s._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[v("h1",{attrs:{id:"css-模块化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css-模块化"}},[s._v("#")]),s._v(" CSS 模块化")]),s._v(" "),v("ul",[v("li",[s._v("CSS 发展")]),s._v(" "),v("li",[s._v("CSS 模块化定义")]),s._v(" "),v("li",[s._v("CSS 模块化的实现方式")])]),s._v(" "),v("h2",{attrs:{id:"css-发展"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css-发展"}},[s._v("#")]),s._v(" CSS 发展")]),s._v(" "),v("p",[s._v("我们在书写 CSS 的时候其实经历了一下几个阶段：")]),s._v(" "),v("h3",{attrs:{id:"手写源生-css"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#手写源生-css"}},[s._v("#")]),s._v(" 手写源生 CSS")]),s._v(" "),v("p",[s._v("在我们最初学习写页面的时候，大家都应该都学过怎么去写 CSS，目前也就支持一下几种情况：")]),s._v(" "),v("ul",[v("li",[s._v("行内样式，即直接在 html 中的 style 属性里编写 css 代码。")]),s._v(" "),v("li",[s._v("内嵌样式，即在 html h 中的 style 标签内编写 class，提供给当前页面使用。")]),s._v(" "),v("li",[s._v("导入样式，即在内联样式中 通过 @import 方法，导入其他样式，提供给当前页面使用。")]),s._v(" "),v("li",[s._v("外部样式，即使用 html 中的 link 标签，加载样式，提供给当前页面使用。")])]),s._v(" "),v("p",[s._v("然后我们在不断摸索中，逐渐形成了以编写"),v("strong",[s._v("内嵌样式")]),s._v("和"),v("strong",[s._v("外部样式")]),s._v("为主要的编写习惯。")]),s._v(" "),v("p",[s._v("读到这里大家肯定有所疑问，为什么不建议使用行内样式？")]),s._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[s._v("使用行内样式的缺点")]),s._v(" "),v("ul",[v("li",[s._v("样式不能复用。")]),s._v(" "),v("li",[s._v("样式权重太高，样式不好覆盖。")]),s._v(" "),v("li",[s._v("表现层与结构层没有分离。")]),s._v(" "),v("li",[s._v("不能进行缓存，影响加载效率。")])])]),s._v(" "),v("p",[s._v("然后我们继续剖析一下，为什么不建议使用导入样式？")]),s._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[s._v("使用导入样式的缺点")]),s._v(" "),v("p",[s._v("经测试，在 CSS 中使用 @import 会有以下两种情况：")]),s._v(" "),v("p",[s._v("1、在 IE6-8 下，@import 声明指向的样式表并不会与页面其他资源并发加载，而是等页面所有资源加载完成后才开始下载。")]),s._v(" "),v("p",[s._v("2、当在 link 标签中去 @import 其他 css，页面会等到所有资源加载完成后才开始。")]),s._v(" "),v("ul",[v("li",[s._v("导入样式，只能放在 style 标签的第一行，")]),s._v(" "),v("li",[s._v("@import 声明的样式表不能充分利用浏览器并发请求资源的行为，因为其加载行为往往会延后触发或会被其他资源加载挂起。")]),s._v(" "),v("li",[s._v("由于 @import 样式表的延后加载，可能会导致页面样式闪烁。")])])]),s._v(" "),v("h3",{attrs:{id:"使用预处理器-sass-less"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用预处理器-sass-less"}},[s._v("#")]),s._v(" 使用预处理器 sass/less")]),s._v(" "),v("p",[s._v("随着时间的不断发展，我们逐渐发现，编写源生的 css 其实并不友好，例如：源生的 css 不支持变量，不支持嵌套，不支持父选择器等等，这些种种问题，催生出了像 sass/less 这样的预处理器。")]),s._v(" "),v("p",[s._v("预处理器主要是强化了 css 的语法，弥补了上文说了这些问题，但本质上，打包出来的结果和源生的 css 都是一样的，只能起到良好的开发效果。")]),s._v(" "),v("h3",{attrs:{id:"后处理器-postcss"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#后处理器-postcss"}},[s._v("#")]),s._v(" 后处理器 postcss")]),s._v(" "),v("p",[s._v("随着前端工程化的不断发展，越来越多的工具被前端大佬们开发出来，愿景是把所有的重复性的工作都交给机器去做，在 css 领域就产生了 postcss。")]),s._v(" "),v("p",[s._v("postcss 可以称作为 css 界的 babel，它的实现原理是通过 ast 去分析我们的 css 代码，然后将分析的结果进行处理，目的是让最终生成的 css 更高效。")]),s._v(" "),v("p",[s._v("常用的 postcss 使用场景有：")]),s._v(" "),v("ul",[v("li",[s._v("配合 stylelint 校验 css 语法")]),s._v(" "),v("li",[s._v("自动增加浏览器前缀 autoprefixer")]),s._v(" "),v("li",[s._v("编译 css next 的语法")])]),s._v(" "),v("h3",{attrs:{id:"css-模块化迅速发展"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css-模块化迅速发展"}},[s._v("#")]),s._v(" css 模块化迅速发展")]),s._v(" "),v("h2",{attrs:{id:"css-模块化定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css-模块化定义"}},[s._v("#")]),s._v(" CSS 模块化定义")]),s._v(" "),v("h2",{attrs:{id:"css-模块化的实现方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css-模块化的实现方式"}},[s._v("#")]),s._v(" CSS 模块化的实现方式")]),s._v(" "),v("h3",{attrs:{id:"css-modules"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css-modules"}},[s._v("#")]),s._v(" CSS Modules")]),s._v(" "),v("h3",{attrs:{id:"css-in-js"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css-in-js"}},[s._v("#")]),s._v(" CSS In Js")])])}),[],!1,null,null,null);t.default=a.exports}}]);